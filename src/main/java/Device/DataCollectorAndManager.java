package Device;

import Configuration.SmartParkingConfiguration;
import Message.RegisterMessage;
import Message.ParkingAvailabilityControlMessage;
import Message.TelemetryMessage;
import Resource.ParkingLed;
import Utils.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Optional;

/*
    There is one Data Collector & Manager for each Parking lot.
    This server use the information create by each Parking Smart Object and process the information
    using MQTT to exchange the information.
    this server have this functionalities:
        -receive in real time the data generated by each Parking Smart Object
        -expose the generated data to the Cloud Server who manage each Parking lot
        -Accept the change of state of each parking by request of the cloud server
        -Calculate the average time of occupation


    Author Henrique Saccani
 */

// Path example : smartparking/lot/verona001/parkingregister
//                smartparking/lot/mantova001/parking/0001/control
//                smartparking/lot/mantova001/information
//                smartparking/lot/verona001/parking/0001/sensor/presence
public class DataCollectorAndManager {
    private static final Logger logger = LoggerFactory.getLogger(DataCollectorAndManager.class);
    public  static final String BASIC_TOPIC = SmartParkingConfiguration.BASIC_TOPIC;
    public static final String PARKING_TOPIC= SmartParkingConfiguration.PARKING_TOPIC;
    public static final String LED_COLOR_TOPIC = SmartParkingConfiguration.LED_COLOR_TOPIC;
    public static final String REGISTER_TOPIC= SmartParkingConfiguration.REGISTER_TOPIC;
    public static final String AVAILABILITY_TOPIC = SmartParkingConfiguration.AVAILABILITY_TOPIC;
    public static final String INFORMATION_TOPIC= SmartParkingConfiguration.INFORMATION_TOPIC;
    public static final String CONTROL_AVAILABILITY_TOPIC=SmartParkingConfiguration.CONTROL_AVAILABILITY_TOPIC;

    public static final String MESSAGE_PARKING_LOT_INFORMATION_TYPE = SmartParkingConfiguration.MESSAGE_PARKING_LOT_INFORMATION_TYPE;
    public static final String MESSAGE_PARKING_AVAILABILITY_CONTROL_TYPE = SmartParkingConfiguration.MESSAGE_PARKING_AVAILABILITY_CONTROL_TYPE;


    public int QOS_VALUE= SmartParkingConfiguration.QOS_VALUE;
    private String lotId;
    private MqttClient mqttClient;
    private HashMap<String, ParkingDescriptor> parkingList; // topic / ParkingDescriptor
    private HashMap<String, ArrayList<Long>> parkingTime; // topic / last parking times of that spot
    private HashMap<String, ParkingTimeDescriptor> currentOccupiedParkingTime;//current occupied parkings spots with the timestamp of when the led became red
    private ArrayList<String> unavailableParkingSpots; //current unavailable parkings spots
    private ObjectMapper mapper;
    private ParkingLotInformationDescriptor parkingLotInformationDescriptor;
    private boolean firstTimeSettingLotDescriptor = true;

    public DataCollectorAndManager(){

    }

    public void init(MqttClient mqttClient, String lotId) {
        this.lotId = lotId;
        this.mqttClient = mqttClient;
        logger.info("Initializing Data Collector and Manager from lot id :{}",lotId);
        parkingList=new HashMap<>();
        parkingTime=new HashMap<>();
        parkingLotInformationDescriptor = new ParkingLotInformationDescriptor(new ArrayList<>(),new HashMap<>());
        currentOccupiedParkingTime = new HashMap<>();
        unavailableParkingSpots = new ArrayList<>();
        this.mapper = new ObjectMapper();
    }

    public void start() throws MqttException {

        logger.info("Starting Data Collector And Manager from lot: {}",lotId);
        subscribeToTopic();
    }

    public void subscribeToTopic() throws MqttException {
        this.mqttClient.subscribe(String.format("%s/%s/#", BASIC_TOPIC,lotId), (topic, msg) -> {
            byte[] payload = msg.getPayload();
            logger.info("Message Received -> Topic: {} - Payload: {}", topic, new String(payload));
            if (topic.contains(REGISTER_TOPIC)){
                Optional <RegisterMessage> optionalRegisterMessage=parseRegisterMessage(msg);
                if(optionalRegisterMessage.isPresent()){
                    logger.info("Analyzing parking register message");
                    try {
                        ParkingDescriptor parkingDescriptor = optionalRegisterMessage.get().getDataValue();
                        String parkingTopic=String.format("%s/%s/%s/%s",BASIC_TOPIC,lotId,PARKING_TOPIC,parkingDescriptor.getParkingId());
                        parkingList.put(parkingTopic,parkingDescriptor);
                        parkingTime.put(parkingTopic,new ArrayList<>());
                        parkingLotInformationDescriptor.addParkingSpot(parkingTopic,parkingList.get(parkingTopic));
                        logger.info("Successfully registered parking spot {}",parkingDescriptor.getParkingId());
                    }catch (Exception e){
                        logger.error(e.getLocalizedMessage());
                    }

                }else {
                    logger.info("Empty or wrong parking register message");
                }
            }

            if(topic.contains(LED_COLOR_TOPIC)){
                Optional <TelemetryMessage> optionalTelemetryMessage = parseTelemetryMessage(msg);
                if(optionalTelemetryMessage.isPresent()){
                    try {
                        parkingList.forEach((key,value) -> { //To reed the data topic must be registered
                            if(topic.contains(key)){
                                if(currentOccupiedParkingTime.containsKey(key)){ //means now the parking should be free
                                    if(optionalTelemetryMessage.get().getDataValue().equals(ParkingLed.FREE_PARKING_LED_COLOR)){
                                        long occupiedTime = optionalTelemetryMessage.get().getTimestamp()- currentOccupiedParkingTime.get(key).getTimestamp();
                                        logger.info("Parking {} was occupied for {} Milliseconds",topic.replace(LED_COLOR_TOPIC,"").replace(String.format("%s/%s/%s",BASIC_TOPIC,lotId,PARKING_TOPIC),"").replace("/","")
                                                ,occupiedTime);
                                        parkingTime.get(key).add(occupiedTime);
                                        currentOccupiedParkingTime.remove(key);
                                        parkingLotInformationDescriptor.addFreeParkingSpot(topic.replace(LED_COLOR_TOPIC,""));

                                        if (firstTimeSettingLotDescriptor){
                                            parkingLotInformationDescriptor.setAverageParkingTimeInMilli(occupiedTime);
                                            firstTimeSettingLotDescriptor = false;
                                        }else {
                                            parkingLotInformationDescriptor.setAverageParkingTimeInMilli(((parkingLotInformationDescriptor.getAverageParkingTimeInMilli() + occupiedTime)/2));
                                        }
                                    }else{
                                        logger.info("parking still occupied, unexpected behaviour");
                                    }

                                }else {
                                    if (optionalTelemetryMessage.get().getDataValue().equals(ParkingLed.OCCUPIED_PARKING_LED_COLOR)){
                                        currentOccupiedParkingTime.put(key, new ParkingTimeDescriptor(key,optionalTelemetryMessage.get().getTimestamp(), (String)optionalTelemetryMessage.get().getDataValue()));
                                        logger.info("Parking {} is occupied, timestamp successfully registered",topic.replace(LED_COLOR_TOPIC,"").replace(String.format("%s/%s/%s",BASIC_TOPIC,lotId,PARKING_TOPIC),"").replace("/",""));
                                        parkingLotInformationDescriptor.removeFreeParkingSpot(topic.replace(LED_COLOR_TOPIC,""));
                                    }
                                }
                                publishLotInformation();
                            }

                        });
                    }catch (Exception e){
                        logger.error(e.getLocalizedMessage());
                    }
                }
                else {
                    logger.info("Empty or wrong Led color telemetry message");
                }
            }

            if(topic.contains(CONTROL_AVAILABILITY_TOPIC)){
                Optional <ParkingAvailabilityControlMessage> optionalParkingAvailabilityControlMessage=parseParkingAvailabilityControlMessage(msg);
                if(optionalParkingAvailabilityControlMessage.isPresent()){
                    logger.info("Analyzing Parking Availability Control Message");
                    try {
                        AvailabilityControlDescriptor availabilityControlDescriptor = (AvailabilityControlDescriptor) optionalParkingAvailabilityControlMessage.get().getDataValue();
                        boolean reserved = parkingAvailabilityControl(availabilityControlDescriptor);
                        if (reserved){
                            logger.info("parking spot {} is now {}",availabilityControlDescriptor.getParkingId(),availabilityControlDescriptor.isUnavailable() ? "unavailable": "avaliable" );
                        }else{
                            logger.info("Error during reservation of parking spot {}",availabilityControlDescriptor.getParkingId());
                        }

                    }catch (Exception e){
                        logger.error(e.getLocalizedMessage());
                    }

                }else {
                    logger.info("Empty or wrong parking register message");
                }
            }
        });
    }

    //Control the availability of a parking spot
    private boolean parkingAvailabilityControl(AvailabilityControlDescriptor availabilityControlDescriptor){
        try {
            String topic = String.format("%s/%s/%s/%s",BASIC_TOPIC,lotId,PARKING_TOPIC,availabilityControlDescriptor.getParkingId());
            boolean disable = availabilityControlDescriptor.isUnavailable();
            logger.info("{} parking spot is now {}", topic, disable ? "available" : "unavailable");
            publishTelemetryData(
                    String.format("%s/%s", topic, AVAILABILITY_TOPIC),
                    new TelemetryMessage<>(MESSAGE_PARKING_AVAILABILITY_CONTROL_TYPE, availabilityControlDescriptor)
            );
            if (disable) {
                unavailableParkingSpots.add(topic);
                currentOccupiedParkingTime.remove(topic);
            } else {
                unavailableParkingSpots.remove(topic);
            }
                return true;
        } catch (MqttException | JsonProcessingException e) {
            logger.error(e.getLocalizedMessage());
            return false;
        }
    }

    private void publishLotInformation() {
        try {
            publishInformationData(
                    String.format("%s/%s/%s/%s", BASIC_TOPIC, lotId,PARKING_TOPIC,INFORMATION_TOPIC),
                    new TelemetryMessage<>(MESSAGE_PARKING_LOT_INFORMATION_TYPE,parkingLotInformationDescriptor));
        } catch (MqttException | JsonProcessingException e) {
            logger.error(e.getLocalizedMessage());
        }
    }

    private Optional<ParkingAvailabilityControlMessage> parseParkingAvailabilityControlMessage(MqttMessage msg) {
        try {
            if (msg == null) {
                logger.error("Null message received in ParkingAvailabilityControlMessage");
                return Optional.empty();
            }
            byte[] payloadByteArray = msg.getPayload();
            String payloadString = new String(payloadByteArray);

            return Optional.ofNullable(mapper.readValue(payloadString, new TypeReference<ParkingAvailabilityControlMessage>() {
            }));

        } catch (Exception e) {
            logger.error(e.getLocalizedMessage());
            return Optional.empty();
        }
    }

    private Optional<RegisterMessage> parseRegisterMessage(MqttMessage msg) {
        try {
            if (msg == null) {
                logger.error("Null message received in RegisterMessage");
                return Optional.empty();
            }
            byte[] payloadByteArray = msg.getPayload();
            String payloadString = new String(payloadByteArray);

            return Optional.ofNullable(mapper.readValue(payloadString, new TypeReference<RegisterMessage>() {
            }));

        } catch (Exception e) {
            logger.error(e.getLocalizedMessage());
            return Optional.empty();
        }
    }

    private Optional<TelemetryMessage> parseTelemetryMessage(MqttMessage msg) {
        try {
            if (msg == null) {
                logger.error("Null message received");
                return Optional.empty();
            }
            byte[] payloadByteArray = msg.getPayload();
            String payloadString = new String(payloadByteArray);

            return Optional.ofNullable(mapper.readValue(payloadString, new TypeReference<TelemetryMessage>() {
            }));

        } catch (Exception e) {
            logger.error(e.getLocalizedMessage());
            return Optional.empty();
        }
    }

    //retained is true
    private void publishInformationData(String topic, TelemetryMessage<?> telemetryMessage) throws MqttException, JsonProcessingException {

        logger.info("Sending to topic: {} -> Data: {}", topic, telemetryMessage);

        if(this.mqttClient != null && this.mqttClient.isConnected() && telemetryMessage != null && topic != null){

            String messagePayload = mapper.writeValueAsString(telemetryMessage);

            MqttMessage mqttMessage = new MqttMessage(messagePayload.getBytes());
            mqttMessage.setQos(QOS_VALUE);
            mqttMessage.setRetained(true);

            mqttClient.publish(topic, mqttMessage);

            logger.info("Data Correctly Published to topic: {}", topic);

        }
        else
            logger.error("Error: Topic or Msg = Null or MQTT Client is not Connected !");
    }
    //retained is false
    private void publishTelemetryData(String topic, TelemetryMessage<?> telemetryMessage) throws MqttException, JsonProcessingException {

        logger.info("Sending to topic: {} -> Data: {}", topic, telemetryMessage);

        if(this.mqttClient != null && this.mqttClient.isConnected() && telemetryMessage != null && topic != null){

            String messagePayload = mapper.writeValueAsString(telemetryMessage);

            MqttMessage mqttMessage = new MqttMessage(messagePayload.getBytes());
            mqttMessage.setQos(QOS_VALUE);
            mqttClient.publish(topic, mqttMessage);

            logger.info("Data Correctly Published to topic: {}", topic);

        }
        else
            logger.error("Error: Topic or Msg = Null or MQTT Client is not Connected !");
    }

    @Override
    public String toString() {
        return "DataCollectorAndManager{" +
                "QOS_VALUE=" + QOS_VALUE +
                ", lotId='" + lotId + '\'' +
                ", mqttClient=" + mqttClient +
                ", parkingList=" + parkingList +
                ", parkingTime=" + parkingTime +
                ", currentOccupiedParkingTime=" + currentOccupiedParkingTime +
                ", unavailableParkingSpots=" + unavailableParkingSpots +
                ", mapper=" + mapper +
                ", parkingLotInformationDescriptor=" + parkingLotInformationDescriptor +
                ", firstTimeSettingLotDescriptor=" + firstTimeSettingLotDescriptor +
                '}';
    }
}
